========
Analysis
========

This guide covers how to analyze the output files generated by **05_advanced_run.py** simulations.

Output File Structure
=====================

Each simulation creates a directory with several output files:

.. code-block:: text

   experiment_name_coupling_1e-03/
   ├── prod-1.gsd              # Trajectory file (HOOMD format)
   ├── prod-1-energy.txt       # Energy tracking data
   ├── prod-1-cavity_mode.txt  # Cavity mode properties
   ├── prod-1-fkt.txt          # F(k,t) correlation data (if enabled)
   └── prod-1.log              # Simulation log

Energy Analysis
===============

**Energy Conservation**

The energy file contains comprehensive energy tracking:

.. code-block:: python

   import pandas as pd
   import matplotlib.pyplot as plt

   # Load energy data
   data = pd.read_csv('experiment_coupling_1e-03/prod-1-energy.txt', delimiter='\t')

   # Plot total energy conservation
   plt.figure(figsize=(12, 8))
   
   plt.subplot(2, 2, 1)
   plt.plot(data['time_ps'], data['total_energy'])
   plt.xlabel('Time (ps)')
   plt.ylabel('Total Energy (Hartree)')
   plt.title('Energy Conservation')

   # Calculate energy drift
   initial_energy = data['total_energy'].iloc[0]
   final_energy = data['total_energy'].iloc[-1]
   drift = (final_energy - initial_energy) / initial_energy
   plt.text(0.02, 0.98, f'Drift: {drift:.2e}', transform=plt.gca().transAxes, va='top')

**Energy Components**

.. code-block:: python

   # Plot energy components
   plt.subplot(2, 2, 2)
   plt.plot(data['time_ps'], data['kinetic_energy'], label='Kinetic')
   plt.plot(data['time_ps'], data['potential_energy'], label='Potential')
   if 'cavity_energy' in data.columns:
       plt.plot(data['time_ps'], data['cavity_energy'], label='Cavity')
   plt.xlabel('Time (ps)')
   plt.ylabel('Energy (Hartree)')
   plt.title('Energy Components')
   plt.legend()

**Temperature Analysis**

.. code-block:: python

   # Plot temperature evolution
   plt.subplot(2, 2, 3)
   plt.plot(data['time_ps'], data['temperature'])
   plt.xlabel('Time (ps)')
   plt.ylabel('Temperature (K)')
   plt.title('Temperature Evolution')

   # Plot cavity temperature if available
   if 'cavity_temperature' in data.columns:
       plt.subplot(2, 2, 4)
       plt.plot(data['time_ps'], data['cavity_temperature'])
       plt.xlabel('Time (ps)')
       plt.ylabel('Cavity Temperature (K)')
       plt.title('Cavity Mode Temperature')

   plt.tight_layout()
   plt.show()

Cavity Mode Analysis
====================

**Cavity Dynamics**

.. code-block:: python

   # Load cavity mode data
   cavity_data = pd.read_csv('experiment_coupling_1e-03/prod-1-cavity_mode.txt', delimiter='\t')

   plt.figure(figsize=(12, 6))
   
   # Plot cavity amplitude
   plt.subplot(1, 2, 1)
   plt.plot(cavity_data['time_ps'], cavity_data['amplitude'])
   plt.xlabel('Time (ps)')
   plt.ylabel('Cavity Amplitude')
   plt.title('Cavity Mode Amplitude')

   # Plot cavity phase
   plt.subplot(1, 2, 2)
   plt.plot(cavity_data['time_ps'], cavity_data['phase'])
   plt.xlabel('Time (ps)')
   plt.ylabel('Phase (rad)')
   plt.title('Cavity Mode Phase')

   plt.tight_layout()
   plt.show()

**Cavity-Molecule Coupling**

.. code-block:: python

   # Calculate coupling energy
   if 'coupling_energy' in cavity_data.columns:
       plt.figure(figsize=(10, 6))
       plt.plot(cavity_data['time_ps'], cavity_data['coupling_energy'])
       plt.xlabel('Time (ps)')
       plt.ylabel('Coupling Energy (Hartree)')
       plt.title('Cavity-Molecule Coupling Energy')
       plt.show()

**Power Spectral Analysis**

.. code-block:: python

   import numpy as np
   from scipy import signal

   # Calculate power spectrum of cavity amplitude
   time_step = cavity_data['time_ps'].iloc[1] - cavity_data['time_ps'].iloc[0]
   freq, psd = signal.periodogram(cavity_data['amplitude'], fs=1/time_step)

   plt.figure(figsize=(10, 6))
   plt.semilogy(freq, psd)
   plt.xlabel('Frequency (1/ps)')
   plt.ylabel('Power Spectral Density')
   plt.title('Cavity Mode Power Spectrum')
   plt.xlim(0, 2)  # Focus on low frequencies
   plt.show()

F(k,t) Correlation Analysis
===========================

If F(k,t) tracking was enabled (``--enable-fkt``):

**Autocorrelation Functions**

.. code-block:: python

   # Load F(k,t) data
   fkt_data = pd.read_csv('experiment_coupling_1e-03/prod-1-fkt.txt', delimiter='\t')

   plt.figure(figsize=(12, 6))
   
   # Plot time evolution
   plt.subplot(1, 2, 1)
   plt.plot(fkt_data['time_ps'], fkt_data['current_autocorr'])
   plt.xlabel('Time (ps)')
   plt.ylabel('F(k,t)')
   plt.title('Density Autocorrelation Function')

   # Plot correlation decay
   if len(fkt_data) > 100:
       # Focus on decay region
       decay_data = fkt_data[fkt_data['time_ps'] <= 50]  # First 50 ps
       plt.subplot(1, 2, 2)
       plt.semilogy(decay_data['time_ps'], np.abs(decay_data['current_autocorr']))
       plt.xlabel('Time (ps)')
       plt.ylabel('|F(k,t)|')
       plt.title('Correlation Decay (log scale)')

   plt.tight_layout()
   plt.show()

**Correlation Time Analysis**

.. code-block:: python

   # Fit exponential decay to extract correlation time
   from scipy.optimize import curve_fit

   def exponential_decay(t, A, tau, offset):
       return A * np.exp(-t/tau) + offset

   # Use data where correlation is positive and significant
   valid_mask = (fkt_data['time_ps'] <= 20) & (fkt_data['current_autocorr'] > 0.1)
   if valid_mask.sum() > 10:
       t_fit = fkt_data['time_ps'][valid_mask]
       y_fit = fkt_data['current_autocorr'][valid_mask]
       
       try:
           popt, _ = curve_fit(exponential_decay, t_fit, y_fit, p0=[1.0, 5.0, 0.0])
           tau_corr = popt[1]
           
           plt.figure(figsize=(10, 6))
           plt.plot(fkt_data['time_ps'], fkt_data['current_autocorr'], 'b-', label='Data')
           plt.plot(t_fit, exponential_decay(t_fit, *popt), 'r--', 
                   label=f'Fit: τ = {tau_corr:.2f} ps')
           plt.xlabel('Time (ps)')
           plt.ylabel('F(k,t)')
           plt.title('Correlation Function Fit')
           plt.legend()
           plt.show()
           
           print(f"Correlation time: {tau_corr:.2f} ps")
       except:
           print("Could not fit exponential decay")

Trajectory Analysis
===================

**Loading GSD Files**

.. code-block:: python

   import gsd.hoomd

   # Load trajectory
   with gsd.hoomd.open('experiment_coupling_1e-03/prod-1.gsd', 'r') as traj:
       print(f"Number of frames: {len(traj)}")
       print(f"Number of particles: {traj[0].particles.N}")
       
       # Get particle types
       types = traj[0].particles.types
       print(f"Particle types: {types}")

**Structural Analysis**

.. code-block:: python

   import numpy as np

   # Calculate molecular center of mass motion
   with gsd.hoomd.open('experiment_coupling_1e-03/prod-1.gsd', 'r') as traj:
       com_positions = []
       
       for frame in traj[::10]:  # Every 10th frame
           # Select molecular particles (exclude cavity 'L' type)
           molecular_mask = frame.particles.typeid != 2  # Assuming 'L' is type 2
           positions = frame.particles.position[molecular_mask]
           masses = frame.particles.mass[molecular_mask]
           
           # Calculate center of mass
           com = np.average(positions, axis=0, weights=masses)
           com_positions.append(com)
       
       com_positions = np.array(com_positions)

   # Plot COM motion
   time_points = np.arange(len(com_positions)) * 10  # Frame spacing
   
   plt.figure(figsize=(12, 4))
   for i, label in enumerate(['X', 'Y', 'Z']):
       plt.subplot(1, 3, i+1)
       plt.plot(time_points, com_positions[:, i])
       plt.xlabel('Frame')
       plt.ylabel(f'COM {label} Position')
       plt.title(f'Center of Mass - {label}')
   plt.tight_layout()
   plt.show()

Comparative Analysis
====================

**Comparing Different Coupling Strengths**

.. code-block:: python

   import glob

   # Load data from multiple coupling strengths
   coupling_dirs = glob.glob('*coupling_*')
   
   plt.figure(figsize=(12, 8))
   
   for i, directory in enumerate(sorted(coupling_dirs)):
       # Extract coupling value from directory name
       coupling = directory.split('coupling_')[1]
       
       # Load energy data
       energy_file = f"{directory}/prod-1-energy.txt"
       try:
           data = pd.read_csv(energy_file, delimiter='\t')
           
           # Plot energy evolution
           plt.subplot(2, 2, 1)
           plt.plot(data['time_ps'], data['total_energy'], label=f'g = {coupling}')
           
           # Plot temperature
           plt.subplot(2, 2, 2)
           plt.plot(data['time_ps'], data['temperature'], label=f'g = {coupling}')
           
       except FileNotFoundError:
           continue

   plt.subplot(2, 2, 1)
   plt.xlabel('Time (ps)')
   plt.ylabel('Total Energy (Hartree)')
   plt.title('Energy vs Coupling Strength')
   plt.legend()

   plt.subplot(2, 2, 2)
   plt.xlabel('Time (ps)')
   plt.ylabel('Temperature (K)')
   plt.title('Temperature vs Coupling Strength')
   plt.legend()

   plt.tight_layout()
   plt.show()

**Statistical Analysis Across Replicas**

.. code-block:: python

   # Analyze multiple replicas for statistical significance
   replica_files = glob.glob('experiment_coupling_1e-03/prod-*-energy.txt')
   
   final_energies = []
   avg_temperatures = []
   
   for file in replica_files:
       data = pd.read_csv(file, delimiter='\t')
       final_energies.append(data['total_energy'].iloc[-1])
       avg_temperatures.append(data['temperature'].mean())
   
   print(f"Final energy: {np.mean(final_energies):.6f} ± {np.std(final_energies):.6f} Hartree")
   print(f"Average temperature: {np.mean(avg_temperatures):.2f} ± {np.std(avg_temperatures):.2f} K")
   
   # Plot distributions
   plt.figure(figsize=(10, 4))
   
   plt.subplot(1, 2, 1)
   plt.hist(final_energies, bins=10, alpha=0.7)
   plt.xlabel('Final Energy (Hartree)')
   plt.ylabel('Frequency')
   plt.title('Final Energy Distribution')
   
   plt.subplot(1, 2, 2)
   plt.hist(avg_temperatures, bins=10, alpha=0.7)
   plt.xlabel('Average Temperature (K)')
   plt.ylabel('Frequency')
   plt.title('Temperature Distribution')
   
   plt.tight_layout()
   plt.show()

Performance Analysis
====================

**Simulation Performance**

.. code-block:: python

   # Extract performance data from log files
   import re

   def parse_log_file(log_file):
       with open(log_file, 'r') as f:
           content = f.read()
           
       # Extract performance metrics
       ns_per_day = re.findall(r'ns_per_day.*?(\d+\.?\d*)', content)
       if ns_per_day:
           return float(ns_per_day[-1])
       return None

   # Analyze performance across different conditions
   log_files = glob.glob('*/prod-1.log')
   performance_data = []
   
   for log_file in log_files:
       performance = parse_log_file(log_file)
       if performance:
           directory = log_file.split('/')[0]
           performance_data.append((directory, performance))
   
   if performance_data:
       directories, performances = zip(*performance_data)
       
       plt.figure(figsize=(12, 6))
       plt.bar(range(len(directories)), performances)
       plt.xlabel('Simulation')
       plt.ylabel('Performance (ns/day)')
       plt.title('Simulation Performance')
       plt.xticks(range(len(directories)), directories, rotation=45, ha='right')
       plt.tight_layout()
       plt.show()

Common Analysis Patterns
========================

**Energy Conservation Check**

.. code-block:: python

   def check_energy_conservation(energy_file, tolerance=1e-3):
       """Check if energy is conserved within tolerance."""
       data = pd.read_csv(energy_file, delimiter='\t')
       
       initial_energy = data['total_energy'].iloc[0]
       final_energy = data['total_energy'].iloc[-1]
       drift = abs(final_energy - initial_energy) / abs(initial_energy)
       
       is_conserved = drift < tolerance
       
       return {
           'is_conserved': is_conserved,
           'drift': drift,
           'initial_energy': initial_energy,
           'final_energy': final_energy
       }

   # Check all simulations
   energy_files = glob.glob('*/prod-*-energy.txt')
   for file in energy_files:
       result = check_energy_conservation(file)
       status = "✓" if result['is_conserved'] else "✗"
       print(f"{file}: {status} Drift = {result['drift']:.2e}")

**Cavity Effect Analysis**

.. code-block:: python

   def compare_cavity_vs_control(cavity_dir, control_dir):
       """Compare cavity vs control simulation."""
       
       # Load cavity simulation
       cavity_data = pd.read_csv(f'{cavity_dir}/prod-1-energy.txt', delimiter='\t')
       control_data = pd.read_csv(f'{control_dir}/prod-1-energy.txt', delimiter='\t')
       
       # Compare average temperatures
       cavity_temp = cavity_data['temperature'].mean()
       control_temp = control_data['temperature'].mean()
       
       # Compare final energies
       cavity_energy = cavity_data['total_energy'].iloc[-1]
       control_energy = control_data['total_energy'].iloc[-1]
       
       print(f"Temperature difference: {cavity_temp - control_temp:.2f} K")
       print(f"Energy difference: {cavity_energy - control_energy:.6f} Hartree")
       
       return {
           'temp_diff': cavity_temp - control_temp,
           'energy_diff': cavity_energy - control_energy
       }

Next Steps
==========

* Explore :doc:`parameter_sweeps` for systematic analysis across parameters
* Check :doc:`troubleshooting` for analysis-related issues
* See :doc:`basic_usage` for generating more analysis data 